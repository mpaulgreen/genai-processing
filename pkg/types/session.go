package types

import (
	"time"
)

// ConversationEntry represents a single conversation interaction.
// This struct stores the query, response, and metadata for each interaction.
type ConversationEntry struct {
	// Timestamp is when this interaction occurred
	Timestamp time.Time `json:"timestamp"`

	// Query is the natural language query from the user
	Query string `json:"query"`

	// Response is the structured response generated by the system
	Response *StructuredQuery `json:"response"`

	// ResolvedReferences contains any references that were resolved in this interaction
	ResolvedReferences map[string]string `json:"resolved_references,omitempty"`
}

// ResolvedReference represents a resolved reference from conversation history.
// This struct stores the type of reference and its resolved value.
type ResolvedReference struct {
	// Type indicates the type of reference (user, resource, time, etc.)
	Type string `json:"type"`

	// Value is the resolved value of the reference
	Value string `json:"value"`

	// Timestamp is when this reference was last updated
	Timestamp time.Time `json:"timestamp"`

	// Confidence is the confidence score for this resolution (0.0 to 1.0)
	Confidence float64 `json:"confidence"`
}

// ConversationContext represents the context for a conversation session.
// This struct maintains the complete state and context information needed for multi-turn conversations.
type ConversationContext struct {
	// SessionID is the unique identifier for this conversation session
	SessionID string `json:"session_id"`

	// UserID is the identifier of the user participating in the conversation
	UserID string `json:"user_id"`

	// CreatedAt is when this conversation session was created
	CreatedAt time.Time `json:"created_at"`

	// LastActivity is the timestamp of the last activity in this session
	LastActivity time.Time `json:"last_activity"`

	// ExpiresAt is when this session will expire (for cleanup purposes)
	ExpiresAt time.Time `json:"expires_at"`

	// ConversationHistory contains the complete history of interactions
	ConversationHistory []ConversationEntry `json:"conversation_history"`

	// ResolvedReferences contains the current resolved references for pronoun resolution
	ResolvedReferences map[string]ResolvedReference `json:"resolved_references"`

	// ContextEnrichment contains additional context information for better LLM understanding
	ContextEnrichment map[string]interface{} `json:"context_enrichment,omitempty"`

	// SessionMetadata contains additional session-specific metadata
	SessionMetadata map[string]interface{} `json:"session_metadata,omitempty"`
}

// NewConversationContext creates a new conversation context with default values.
func NewConversationContext(sessionID, userID string) *ConversationContext {
	now := time.Now()
	return &ConversationContext{
		SessionID:           sessionID,
		UserID:              userID,
		CreatedAt:           now,
		LastActivity:        now,
		ExpiresAt:           now.Add(24 * time.Hour), // Default 24-hour expiration
		ConversationHistory: make([]ConversationEntry, 0),
		ResolvedReferences:  make(map[string]ResolvedReference),
		ContextEnrichment:   make(map[string]interface{}),
		SessionMetadata:     make(map[string]interface{}),
	}
}

// AddConversationEntry adds a new conversation entry to the history.
func (cc *ConversationContext) AddConversationEntry(query string, response *StructuredQuery, resolvedRefs map[string]string) {
	entry := ConversationEntry{
		Timestamp:          time.Now(),
		Query:              query,
		Response:           response,
		ResolvedReferences: resolvedRefs,
	}
	cc.ConversationHistory = append(cc.ConversationHistory, entry)
	cc.LastActivity = entry.Timestamp
}

// UpdateResolvedReference updates a resolved reference with new information.
func (cc *ConversationContext) UpdateResolvedReference(key string, refType string, value string, confidence float64) {
	cc.ResolvedReferences[key] = ResolvedReference{
		Type:       refType,
		Value:      value,
		Timestamp:  time.Now(),
		Confidence: confidence,
	}
}

// GetResolvedReference retrieves a resolved reference by key.
func (cc *ConversationContext) GetResolvedReference(key string) (ResolvedReference, bool) {
	ref, exists := cc.ResolvedReferences[key]
	return ref, exists
}

// IsExpired checks if the session has expired.
func (cc *ConversationContext) IsExpired() bool {
	return time.Now().After(cc.ExpiresAt)
}

// ExtendExpiration extends the session expiration by the specified duration.
func (cc *ConversationContext) ExtendExpiration(duration time.Duration) {
	cc.ExpiresAt = time.Now().Add(duration)
}

// GetRecentEntries returns the most recent conversation entries (up to the specified limit).
func (cc *ConversationContext) GetRecentEntries(limit int) []ConversationEntry {
	if limit <= 0 || len(cc.ConversationHistory) == 0 {
		return []ConversationEntry{}
	}

	if limit >= len(cc.ConversationHistory) {
		return cc.ConversationHistory
	}

	return cc.ConversationHistory[len(cc.ConversationHistory)-limit:]
}
